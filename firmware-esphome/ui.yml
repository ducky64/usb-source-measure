# hardware UI like displays, LEDs, and buttons, and supporting state

globals:
  - id: cursor
    type: int
    initial_value: '0'  # 0 = voltage, 1 = current lim max, 2 = current lim min, 3 = range, 4 = reset integrators
  - id: kCursorChoices
    type: int
    initial_value: '5'
  - id: cursorDigit
    type: int[2]
    initial_value: '{-1, -1}'  # 0 = voltage, 1 = current lim min and max (shared)
  - id: kCursorDigitLimits  # note: dynamically changes with current range
    type: int[2][2]
    initial_value: '{{{-3, 1}, {-2, 0}}}'

script:
  - id: encoder_rotate
    parameters:
      increment: int  # 1 for increment, -1 for decrement
    then:
    - lambda: |-
        if (id(cursor) == 0) {
          float delta = pow(10, id(cursorDigit)[0]) * increment;
          id(set_voltage)->make_call().set_value(id(set_voltage)->state + delta).perform();
        } else if (id(cursor) == 1 || id(cursor) == 2) {
          float delta = pow(10, id(cursorDigit)[1]) * increment;
          if (id(cursor) == 1) {
            id(limit_current_max)->make_call().set_value(id(limit_current_max)->state + delta).perform();
          } else if (id(cursor) == 2) {
            id(limit_current_min)->make_call().set_value(id(limit_current_min)->state + delta).perform();
          }
        }
        
  - id: dir_up_down
    parameters:
      increment: int  # 1 for increment, -1 for decrement
    then:
    - lambda: |-
        id(cursor) = (id(cursor) + id(kCursorChoices) + increment) % id(kCursorChoices);  // signed modulo is undefined
        if (id(cursor) == 1 || id(cursor) == 2) {  // clip to limit, if it has changed
          id(cursorDigit)[1] = min(max(id(cursorDigit)[1],
                                       id(kCursorDigitLimits)[1][0]), id(kCursorDigitLimits)[1][1]);
        }
  - id: dir_left_right
    parameters:
      increment: int  # 1 for increment, -1 for decrement
    then:
    - lambda: |-
        if (id(cursor) == 0) {
          id(cursorDigit)[0] = min(max(id(cursorDigit)[0] + increment, 
                                       id(kCursorDigitLimits)[0][0]), id(kCursorDigitLimits)[0][1]);
        } else if (id(cursor) == 1 || id(cursor) == 2) {
          id(cursorDigit)[1] = min(max(id(cursorDigit)[1] + increment, 
                                       id(kCursorDigitLimits)[1][0]), id(kCursorDigitLimits)[1][1]);
        } else if (id(cursor) == 3) {
          auto index = id(current_range).active_index();
          if (index.has_value()) {
            id(current_range)->make_call().set_index(index.value() + increment).perform();
          }

          if (id(current_range).current_option() == "300mA") {
            id(kCursorDigitLimits)[1][0] = -3;
          } else if (id(current_range).current_option() == "30mA") {
            id(kCursorDigitLimits)[1][0] = -4;
          } else {  // assume 3A mode
            id(kCursorDigitLimits)[1][0] = -2;
          }
        } else if (id(cursor) == 4) {
          id(integrator_reset).press();
        }


light:
  - platform: esp32_rmt_led_strip
    id: npx
    rgb_order: GRB
    chipset: SK6812
    pin: GPIO38
    num_leds: 6
    name: "${name} Neopixels"
    initial_state:
      state: ON
    restore_mode: RESTORE_AND_ON  # persistent brightness settings
    default_transition_length: 0s  # instantaneous
    effects:
      - addressable_lambda:
          name: "Smu"
          update_interval: 100ms
          lambda: |-
            // use the pulse counter to track fast current limit transients
            static int lastCurrentSourcePulses = 0, lastCurrentSinkPulses = 0;
            int currentSourcePulses = id(control_limit_source_pulses).state;
            int currentSinkPulses = id(control_limit_sink_pulses).state;
            static bool lastCurrentLimitState = false;  // track the last state to blink on transients
      
            it.all() = Color(0, 0, 0, 0);

            if (!id(conv_en_sense).state) {  // OVP trip makes input LED go red
              it[5] = Color(255, 0, 0, 0);
            } else {  // otherwuse USB-PD state
              switch (id(usbpd).get_state()) {
                case UsbPdStateMachine::kConnected: it[5] = Color(0, 255, 0, 0); break;
                default: it[5] = Color(255, 255, 0, 0);
              }
            }

            if (id(enable).state) {
              if (id(control_limit_source).state ||
                  (lastCurrentSourcePulses != currentSourcePulses && !lastCurrentLimitState)) {
                it[4] = Color(255, 255, 0, 0);

                it[1] = Color(255, 0, 0, 0);
                it[3] = Color(0, 0, 0, 0);

                lastCurrentLimitState = true;
              } else if (id(control_limit_sink).state ||
                  (lastCurrentSinkPulses != currentSinkPulses && !lastCurrentLimitState)) {
                it[4] = Color(255, 255, 0, 0);

                it[1] = Color(0, 0, 0, 0);
                it[3] = Color(255, 0, 0, 0);

                lastCurrentLimitState = false;
              } else {  // voltage mode
                it[4] = Color(0, 255, 0, 0);

                it[1] = Color(0, 0, 0, 0);
                it[3] = Color(0, 0, 0, 0);

                lastCurrentLimitState = false;
              }
            } else {
              it[4] = Color(127, 0, 127, 0);  // dim purple for off
              lastCurrentLimitState = false;
            }
            lastCurrentSourcePulses = currentSourcePulses;
            lastCurrentSinkPulses = currentSinkPulses;
      - addressable_rainbow:
          name: Rainbow  # for testing only
    on_turn_on:
      - light.turn_on:
          id: npx
          effect: "Smu"
  - platform: status_led
    name: "${name} Dbg"
    id: debug_led
    internal: true
    pin:
      number: GPIO0
      inverted: true

text_sensor:
  - platform: wifi_info
    ip_address:
      id: wifi_ip
      internal: true
    ssid:
      id: wifi_ssid
      internal: true

font:
  - file: "resources/4x6.bdf"  # characters actually 3x5 plus 1px descender
    id: bdf4x6
  - file: "resources/6x10.bdf"  # characters actually 5x7 plus 2px descender
    id: bdf6x10

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3c
    reset_pin: GPIO12
    update_interval : 200ms
    lambda: |-
      // use the pulse counter to track fast current limit transients
      static int lastCurrentSourcePulses = 0, lastCurrentSinkPulses = 0;
      int currentSourcePulses = id(control_limit_source_pulses).state;
      int currentSinkPulses = id(control_limit_sink_pulses).state;
      static bool lastCurrentLimitState = false;  // track the last state to blink on transients
      
      int baseline, smallBaseline, dummy;
      id(bdf6x10)->measure("X", &dummy, &dummy, &baseline, &dummy);
      id(bdf4x6)->measure("X", &dummy, &dummy, &smallBaseline, &dummy);

      int smallOffY = baseline - smallBaseline;

      int currentExtraDigits = 0;
      if (id(current_range).current_option() == "300mA") {
        currentExtraDigits = 1;
      } else if (id(current_range).current_option() == "30mA") {
        currentExtraDigits = 2;
      }

      // LEFT HALF: MEASUREMENT SECTION
      int labelX = 0;
      int valueRightX = 65;

      int lineY = 0;
      it.printf(labelX, lineY, id(bdf4x6), "MEAS%s",
          millis() % 1000 >= 500 ? "." : " ");  // liveness indicator
      if (id(kCalVoltageFactor).state == 1 || id(kCalVoltageOffset).state == 0 || id(kCalSetVoltageFactor).state == 1 || id(kCalSetVoltageOffset).state == 0 ||
          id(kCalCurrent0Factor).state == 1 || id(kCalCurrent0Offset).state == 0 || id(kCalSetCurrent0Factor).state == 1 || id(kCalSetCurrent0Offset).state == 0) {
        // TODO currently ignores the current 1 range since it's not supported on most boards
        // default calibration means uncalibrated
        drawInverted(it, valueRightX - 5*4 + 1, lineY, id(bdf4x6), "UNCAL");
      }

      lineY = 5;
      drawValue(it, valueRightX - 5 - drawValueWidth(id(bdf6x10), 2, 6), lineY, 
          id(bdf6x10), 2, 3, id(meas_voltage).get_state());
      it.print(valueRightX - 3, lineY + smallOffY, 
          id(bdf4x6), "V");

      lineY = 15;
      if (id(enable).state) {
        if (id(control_limit_source).state ||
            (lastCurrentSourcePulses != currentSourcePulses && !lastCurrentLimitState)) {
          drawInverted(it, valueRightX - 4*4 + 1, lineY, id(bdf4x6), "LIM+");
          lastCurrentLimitState = true;
        } else if (id(control_limit_sink).state ||
            (lastCurrentSinkPulses != currentSinkPulses && !lastCurrentLimitState)) {
          drawInverted(it, valueRightX - 4*4 + 1, lineY, id(bdf4x6), "LIM-");
          lastCurrentLimitState = true;
        } else {
          lastCurrentLimitState = false;
        }
      } else {
        lastCurrentLimitState = false;
      }
      lastCurrentSourcePulses = currentSourcePulses;
      lastCurrentSinkPulses = currentSinkPulses;
      
      lineY = 20;
      drawValue(it, valueRightX - 5 - drawValueWidth(id(bdf6x10), 1, 6), lineY, 
          id(bdf6x10), 1, 4 + currentExtraDigits, id(meas_current).get_state());
      it.print(valueRightX - 3, lineY + smallOffY, 
          id(bdf4x6), "A");

      lineY = 35;
      drawValue(it, valueRightX - 5 - drawValueWidth(id(bdf6x10), 2, 6), lineY, 
          id(bdf6x10), 2, 4 + currentExtraDigits, id(deriv_power).get_state());
      it.print(valueRightX - 3, lineY + smallOffY, 
          id(bdf4x6), "W");

      lineY = 45;
      float scaledJoules;
      const char* joulesPrefix;
      siPrefixValue(id(deriv_energy).get_state(), &scaledJoules, &joulesPrefix);
      drawValue(it, valueRightX - 5 - drawValueWidth(id(bdf6x10), 3, 3), lineY, 
          id(bdf6x10), 3, 3, scaledJoules);
      it.printf(valueRightX - 3, lineY + smallOffY, 
          id(bdf4x6), "%sJ", joulesPrefix);
      if (id(cursor) == 4) {
        drawInverted(it, 4, lineY + smallOffY, id(bdf4x6), "RST");
      }

      // RIGHT HALF: SETPOINT SECTION
      labelX = 80;
      valueRightX = 127;
      lineY = 0;
      it.printf(labelX, lineY, id(bdf4x6), "SET");
      if (id(enable).state) {
        drawInverted(it, valueRightX - 9, lineY, id(bdf4x6), "ON");
      } else {
        it.print(valueRightX - 11, lineY, id(bdf4x6), "OFF");
      }

      lineY = 5;
      drawValue(it, valueRightX - 5 - drawValueWidth(id(bdf6x10), 2, 4), lineY, 
          id(bdf6x10), 2, 3, id(set_voltage).state,
          id(cursor) == 0 ? id(cursorDigit)[0] : -128);
      it.print(valueRightX - 3, lineY + smallOffY, 
          id(bdf4x6), "V");

      lineY = 15;
      it.printf(labelX, lineY, id(bdf4x6), "LIM+");

      lineY = 20;
      drawValue(it, valueRightX - 5 - drawValueWidth(id(bdf6x10), 1, 4), lineY, 
          id(bdf6x10), 1, 2 + currentExtraDigits, id(limit_current_max).state,
          id(cursor) == 1 ? id(cursorDigit)[1] : -128);
      it.print(valueRightX - 3, lineY + smallOffY, 
          id(bdf4x6), "A");

      lineY = 30;
      it.printf(labelX, lineY, id(bdf4x6), "LIM-");

      lineY = 35;
      drawValue(it, valueRightX - 5 - drawValueWidth(id(bdf6x10), 1, 4), lineY, 
          id(bdf6x10), 1, 2 + currentExtraDigits, id(limit_current_min).state,
          id(cursor) == 2 ? id(cursorDigit)[1] : -128);
      it.print(valueRightX - 3, lineY + smallOffY, 
          id(bdf4x6), "A");

      lineY = 45;
      it.printf(labelX, lineY, id(bdf4x6), "RANGE");
      drawInverted(it, valueRightX - 5*4 + 1, lineY, 
          id(bdf4x6), id(current_range).current_option(),
          id(cursor) == 3);

      // DEVICE INFO
      const uint8_t kSsidMaxChars = 5;
      char wifiSsidTrunc[kSsidMaxChars + 1] = {0};
      strncpy(wifiSsidTrunc, id(wifi_ssid).state.c_str(), kSsidMaxChars);
      it.printf(0, 64, id(bdf4x6), TextAlign::BOTTOM_LEFT, "%s %s",
          wifiSsidTrunc, id(wifi_ip).state.c_str());

      const char* pdState;
      switch (id(usbpd).get_state()) {
        case UsbPdStateMachine::kConnected: pdState = "PD"; break;
        default: pdState = "  ";
      }
      it.printf(128, 64-6, id(bdf4x6), TextAlign::BOTTOM_RIGHT, "%s %2.0fv %2.f,%2.fc", pdState, id(fusb_vbus).get_state(), id(temp_buckboost).state, id(temp_fets).state);
      
      it.printf(128, 64, id(bdf4x6), TextAlign::BOTTOM_RIGHT, "Ducky SMU");

binary_sensor:
  - platform: gpio
    id: encoder_sw
    name: "${name} Encoder Sw"
    internal: true
    pin: 
      number: GPIO40
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
        - switch.toggle: enable
  - platform: gpio
    id: dir_sw
    name: "${name} Dir Sw"
    internal: true
    pin: 
      pca9554: ioe_ui
      number: 1
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
        - lambda: |-
            if (id(cursor) == 4) {
              id(integrator_reset).press();
            }
  - platform: gpio
    name: "${name} Dir Up"
    internal: true
    pin: 
      pca9554: ioe_ui
      number: 0
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
      - script.execute:
          id: dir_up_down
          increment: -1
  - platform: gpio
    name: "${name} Dir Down"
    internal: true
    pin: 
      pca9554: ioe_ui
      number: 3
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
      - script.execute:
          id: dir_up_down
          increment: 1
  - platform: gpio
    name: "${name} Dir Left"
    internal: true
    pin: 
      pca9554: ioe_ui
      number: 2
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
      - script.execute:
          id: dir_left_right
          increment: 1
  - platform: gpio
    name: "${name} Dir Right"
    internal: true
    pin: 
      pca9554: ioe_ui
      number: 7
      inverted: true
      mode:
        input: true
    filters:
      - delayed_on: 10ms
    on_click:
    - then:
      - script.execute:
          id: dir_left_right
          increment: -1

sensor:
  - platform: rotary_encoder
    id: encoder
    name: "${name} Encoder"
    restore_mode: ALWAYS_ZERO
    internal: true
    resolution: 2  # so each detent generates one action
    pin_a:
      number: GPIO42
      inverted: true
      mode:
        input: true
        pullup: true
    pin_b:
      number: GPIO41
      inverted: true
      mode:
        input: true
        pullup: true
    on_clockwise:
    - then:
      - script.execute:
          id: encoder_rotate
          increment: 1
    on_anticlockwise:
    - then:
      - script.execute:
          id: encoder_rotate
          increment: -1