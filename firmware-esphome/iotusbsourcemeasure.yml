substitutions:
  name: "UsbSMU"

packages:
  - !include calibration_vars.yml
  - !include ui.yml
  - !include instrumentation.yml
  - !include characterization.yml

esp32:
  board: esp32-s3-devkitc-1  # 8MB flash without PSRAM
  framework:
    type: esp-idf

esphome:
  name: ducky-iotusbsmu
  name_add_mac_suffix: true
  on_boot:
    - number.set:
        id: set_voltage
        value: 0
    - number.set:
        id: limit_current_min
        value: -0.1
    - number.set:
        id: limit_current_max
        value: 0.1
    - number.set:
        id: buckboost_ratio
        value: 0.0

    - switch.turn_on: conv_enable  # pulse conv enable latch
    - delay: 0.1s
    - switch.turn_off: conv_enable

    - delay: 1.0s  # assume enough time for PD to negotiate
    - switch.turn_on: vin_ramp

  on_loop:
    - script.execute: buckboost_control_loop
  includes:
    - smu_display.h
    - bits2value.h

preferences:
  flash_write_interval: 5s  # so calibration updates save near-immediately

wifi:
  <<: !include ../wifi_config.yaml
  ap:
    ap_timeout: 15s

  reboot_timeout: 0s

captive_portal:

# HASS API
api:
  reboot_timeout: 0s

# Allow API
ota:
  - platform: esphome

# Print Updates
logger:
  level: INFO

# WebServer component, displays some information
web_server:
    port: 80
    local: true

# device constants
globals:
  - id: kBuckBoostPwmDeadzone
    type: float
    initial_value: '0.03'  # in fractional duty-cycle, maximum / minimum duty cycle
  - id: kBuckBoostHeadroom
    type: float
    initial_value: '0.5'  # volts

  - id: kVoltageRatio  # output volts per ADC volt
    type: float
    initial_value: '21.1'  # 1/(0.0426 (divider) * 1.11 (diffamp))
  - id: kCurrentRatio0  # output amps per ADC volt, including accounting for resistor value
    type: float
    initial_value: '1.95'  # 1/(0.1 (resistor) * 5.12 (diffamp))
  - id: kCurrentRatio1
    type: float
    initial_value: '0.195'  # 1/(1 (resistor) * 5.12 (diffamp))
  - id: kCurrentRatio2
    type: float
    initial_value: '0.0195'  # 1/(10 (resistor) * 5.12 (diffamp))

script:
  - id: buckboost_control_loop
    then:
    - lambda: |-
        const float kRampRateVoltsPerS = 25;  // output ramp rate by estimated Vin
        const int kMaxDeltaMillis = 50;  // maximum ramp per iteration

        static auto lastRun = millis();
        auto thisRun = millis();
        auto deltaMillis = min(thisRun - lastRun, (unsigned long)kMaxDeltaMillis);
        if (id(enable).state) {  // only write the buck-boost if target is enable
          // set buck-boost to minimum needed + headroom
          float voltageScalingFactor = max(5.0, (id(fusb_vbus).state - 0.4));  // ratio to output volts = Vin, always expect at least 5
          // must be higher than measured output to avoid the output back-driving Vconv through the FET body diode; should be hardware diode-gated in a future rev
          float convTargetVolts = max(id(set_voltage).state, id(meas_voltage_max).state) + id(kBuckBoostHeadroom);
          float currentConvVolts = id(buckboost_ratio).state * voltageScalingFactor;
          float nextConvVolts = min(currentConvVolts + kRampRateVoltsPerS * deltaMillis / 1000.f, convTargetVolts);
          id(buckboost_ratio).make_call().set_value(nextConvVolts / voltageScalingFactor).perform();
          if (!id(control_enable).state) {  // if not yet turned on
            if (nextConvVolts == convTargetVolts) {  // turn on output enable when target reached
              id(set_enable_range).execute(false);
            }
          }
        } else {  // turn off converter
          id(buckboost_ratio).make_call().set_value(0).perform();
        }
      
  - id: update_current  # update the current, assuming the device is on, or will be turned on
    then:
    - lambda: |-
        float setCurrentFactor = 1, setCurrentOffset = 0;
        if (id(current_range).current_option() == "3A") {
          setCurrentFactor = id(kCalSetCurrent0Factor).state * id(kCurrentRatio0);
          setCurrentOffset = id(kCalSetCurrent0Offset).state;
        } else if (id(current_range).current_option() == "300mA") {
          setCurrentFactor = id(kCalSetCurrent1Factor).state * id(kCurrentRatio1);
          setCurrentOffset = id(kCalSetCurrent1Offset).state;
        } else if (id(current_range).current_option() == "30mA") {
          setCurrentFactor = id(kCalSetCurrent2Factor).state * id(kCurrentRatio2);
          setCurrentOffset = id(kCalSetCurrent2Offset).state;
        } else {
          ESP_LOGE("update_current", "Unknown range %s", id(current_range).current_option());
        }

        id(dac_isink)->write_state(
            0.5 - valueToAdc(id(limit_current_min).state, setCurrentFactor, 1.0, setCurrentOffset));
        id(dac_ratio_isink)->publish_state(id(dac_isink).rawValue / 4095.0 - 0.5);
        id(dac_value_isink)->publish_state(id(dac_isink).rawValue);

        id(dac_isrc)->write_state(
            0.5 - valueToAdc(id(limit_current_max).state, setCurrentFactor, 1.0, setCurrentOffset));
        id(dac_ratio_isrc)->publish_state(id(dac_isrc).rawValue / 4095.0 - 0.5);
        id(dac_value_isrc)->publish_state(id(dac_isrc).rawValue);

  - id: set_enable_range  # sets the overall enable and current ranging IOs, based on the ranging and enable target
    parameters:
      overlap: bool  # if true does not turn off other ranges, this allows overlap (though at a much reduced current limit) during the swap
    then:
    - script.execute: update_current
    - lambda: |-
        if (id(enable).state) {  // turn on, figure out ranging
          if (id(current_range).current_option() == "3A") {
            id(range0).turn_on();
            if (!overlap) {
              id(range1).turn_off();
              id(range2).turn_off();
            }
          } else if (id(current_range).current_option() == "300mA") {
            id(range1).turn_on();
            if (!overlap) {
              id(range0).turn_off();
              id(range2).turn_off();
            }
          } else if (id(current_range).current_option() == "30mA") {
            id(range2).turn_on();
            if (!overlap) {
              id(range0).turn_off();
              id(range1).turn_off();
            }
          } else {
            ESP_LOGE("set_enable_range", "Unknown range %s", id(current_range).current_option());
            return;
          }
          id(control_enable).turn_on();
          id(gate_hi).turn_on();
          id(gate_lo).turn_off();  // TODO apply deadzone, intelligent on/off
        } else {  // turn off
          id(range0).turn_off();
          id(range1).turn_off();
          id(range2).turn_off();
          id(control_enable).turn_off();
          id(gate_hi).turn_off();
          id(gate_lo).turn_off();
        }

  - id: update_voltage  # update the voltage
    then:
    - lambda: |-
        // note, calibration solves for A*dac_coarse + B*dac_fine + C = adc
        // ignoring fine, dac_coarse = (1/A)*(adc - C)
        // with coarse set, dac_fine = (1/B)*(adc - C - A*dac_coarse)
        // note, the calibration factors are actually stored as 1/A, 1/B, and -C

        // calculate the high precision target DAC value
        float targetDac = 0.5 - valueToAdc(id(set_voltage).state, id(kVoltageRatio), id(kCalVoltageFactor).state, id(kCalVoltageOffset).state);
        targetDac = targetDac + id(kCalSetVoltageOffset).state;  // offset is common across both DACs

        // set the coarse voltage first
        id(dac_voltage)->write_state(targetDac * id(kCalSetVoltageFactor).state); // coarse cal is for coarse DAC only
        float quantizedDacVoltageRatio = id(dac_voltage).rawValue / 4095.0;
        id(dac_ratio_voltage)->publish_state(quantizedDacVoltageRatio);
        id(dac_value_voltage)->publish_state(id(dac_voltage).rawValue);

        ESP_LOGI("voltage", "Target %.05f, coarse-raw %i, coarse-contrib %.05f, remain %.05f", 
          targetDac,
          id(dac_voltage).rawValue,
          quantizedDacVoltageRatio / id(kCalSetVoltageFactor).state,
          (targetDac - quantizedDacVoltageRatio / id(kCalSetVoltageFactor).state));

        // then use the fine control to set the remainder
        id(dac_ratio_voltage_fine).make_call().set_value(
            (targetDac - quantizedDacVoltageRatio / id(kCalSetVoltageFactor).state) * id(kCalSetVoltageFineFactor).state
        ).perform();

output:
  - platform: mcpwm_sync
    id: buck_pwm
    pin: GPIO17
    frequency: 500kHz
    deadtime_rising: 0s  # deadtime generated internally by gate driver
    deadtime_falling: 0s
  - platform: mcpwm_sync
    id: boost_pwm
    pin: GPIO18  # this controls the HIGH SIDE switch, so the duty is 1-D
    frequency: 500kHz
    deadtime_rising: 0s  # deadtime generated internally by gate driver
    deadtime_falling: 0s
    max_duty: 0.37  # up to 1.5x boost ratio, accounting for 0.95 buck ratio
    inverted: true

  - platform: mcp4728
    id: dac_voltage
    mcp4728_id: dac_control
    channel: 0
  - platform: mcp4728
    id: dac_voltage_fine
    mcp4728_id: dac_control
    channel: 2
  - platform: mcp4728
    id: dac_isink
    mcp4728_id: dac_control
    channel: 1
  - platform: mcp4728
    id: dac_isrc
    mcp4728_id: dac_control
    channel: 3

switch:
  - platform: template
    id: enable
    name: "${name} Enable"  # published state is the enable target, current state is the state of the ranging GPIOs
    turn_on_action:
      - lambda: id(enable).publish_state(true);
      - script.execute: update_voltage
        # enable handled in buckboost_softstart_loop
    turn_off_action:
      - lambda: id(enable).publish_state(false);
      - script.execute:
          id: set_enable_range
          overlap: false

  - platform: gpio
    id: vin_ramp
    internal: true
    name: "${name} Vin Ramp"
    pin:
      pca9554: ioe_ctl
      number: 0
    on_turn_on:
      then:
        - delay: 100ms
        - lambda: |-
            ESP_LOGI("top", "re-initializing ADC and DAC");
            id(adc_meas).status_clear_error();
            id(adc_meas).setup();
            id(dac_control).status_clear_error();
            id(dac_control).setup();

  - platform: gpio
    id: control_enable
    internal: true
    name: "${name} Integrator Control Enable"
    pin:
      pca9554: ioe_ctl
      number: 4
    inverted: true  # active-low enable
  - platform: gpio
    id: conv_enable
    internal: true
    name: "${name} Conv Enable"
    pin:
      pca9554: ioe_ctl
      number: 2


  - platform: gpio
    id: gate_lo
    internal: true
    name: "${name} Gate Low"
    pin:
      pca9554: ioe_ctl
      number: 7
  - platform: gpio
    id: gate_hi
    internal: true
    name: "${name} Gate High"
    pin:
      pca9554: ioe_ctl
      number: 6

  - platform: gpio
    id: range0
    internal: true
    name: "${name} Range0"
    pin:
      pca9554: ioe_ui
      number: 6
  - platform: gpio
    id: range1
    internal: true
    name: "${name} Range1"
    pin:
      pca9554: ioe_ui
      number: 4
  - platform: gpio
    id: range2
    internal: true
    name: "${name} Range2"
    pin:
      pca9554: ioe_ui
      number: 5

  - platform: gpio
    id: fan
    name: "${name} Fan"
    pin: GPIO39

i2c:
  scl: GPIO15
  sda: GPIO7
  frequency: 400kHz
  scan: false

spi:
  clk_pin: GPIO9
  mosi_pin: GPIO10
  miso_pin: GPIO11

pca9554:
  - id: ioe_ctl
    address: 0x38
  - id: ioe_ui
    address: 0x3A

fusb302:
  id: usbpd
  target: 15v

mcp3561:
  cs_pin: GPIO3
  id: adc_meas
  osr: 40960  # up to 98304

mcp4728:
  id: dac_control

number:
  - platform: template
    name: "${name} Set Voltage"
    id: set_voltage
    icon: mdi:high-voltage
    mode: box
    min_value: 0
    max_value: 30
    step: 0.01
    unit_of_measurement: V
    set_action:
      - then:
        - lambda: id(set_voltage).publish_state(x);
        - script.execute: update_voltage

  - platform: template
    name: "${name} Set Current Min"
    id: limit_current_min
    icon: mdi:pan-up
    mode: box
    min_value: -3
    max_value: -0.01
    step: 0.001
    unit_of_measurement: A
    set_action:
      - then:
        - lambda: id(limit_current_min).publish_state(x);
        - script.execute: update_current
  - platform: template
    name: "${name} Set Current Max"
    id: limit_current_max
    icon: mdi:pan-down
    mode: box
    min_value: 0.01
    max_value: 3
    step: 0.001
    unit_of_measurement: A
    set_action:
      - then:
        - lambda: id(limit_current_max).publish_state(x);
        - script.execute: update_current
  - platform: template
    name: "${name} Buck-boost ratio"
    internal: true
    id: buckboost_ratio
    icon: mdi:pan-down
    min_value: 0
    max_value: 1.5
    step: 0.01
    set_action:
      - then:
        - lambda: |-
            // initialize DC at ratio = 1
            float buckDc = 1 - id(kBuckBoostPwmDeadzone), boostDc = id(kBuckBoostPwmDeadzone);
            if (x == 0) {  // turn off converter
              buckDc = 0;
              boostDc = 0;
            } else if (x <= 1) {  // adjust buck dc
              float boostRatio = 1 / (1 - boostDc);
              buckDc = x / boostRatio;  // offset the minimal boost PWM
            } else {  // adjust boost dc
              float boostRatio = x / buckDc;  // offset the maximum buck PWM
              boostDc = 1 - (1 / boostRatio);
            }
            id(buck_pwm)->write_state(buckDc);
            id(boost_pwm)->write_state(boostDc);
            ESP_LOGD("BuckBoostCtl", "Target %.02f, buck %.02f, boost %.02f", x, buckDc, boostDc);
            id(buckboost_ratio).publish_state(x);

  - platform: template  # unlike the other ratios, this is inout to allow calibration to actuate independently
    name: "${name} Set Ratio Voltage Fine"
    id: dac_ratio_voltage_fine
    min_value: -0.5
    max_value: 0.5
    step: 0.0001
    set_action:
      - then:
        - lambda: |-
            id(dac_voltage_fine)->write_state(x + 0.5);
            // then write back out the quantized value
            id(dac_ratio_voltage_fine).publish_state(id(dac_voltage_fine).rawValue / 4095.0 - 0.5);

select:
  - platform: template  # published state is the target range, current range is the state of the ranging GPIOs
    name: "${name} Set Current Range"
    id: current_range
    options:
     - "3A"
     - "300mA"
     - "30mA"
    initial_option: "3A"
    set_action:
      - lambda: |-
          id(current_range).publish_state(x);
      - script.execute: update_current
      - script.execute:
          id: set_enable_range
          overlap: true
      - delay: 5 ms
      - script.execute:
          id: set_enable_range
          overlap: false

button:
  - platform: template
    id: integrator_reset
    name: Reset integrators
    on_press:
      then:
        - sensor.integration.reset: deriv_energy
        - sensor.integration.reset: deriv_accum_current

binary_sensor:
  - platform: gpio
    id: conv_en_sense
    name: "${name} Conv OVP Sen"
    pin: 
      pca9554: ioe_ctl
      number: 3
      mode:
        input: true

  - platform: gpio
    id: control_limit_source
    name: "${name} Control Limit Source"
    pin: 
      number: GPIO14
      allow_other_uses: true
      mode:
        input: true
        pullup: true
  - platform: gpio
    id: control_limit_sink
    name: "${name} Control Limit Sink"
    pin: 
      number: GPIO21
      allow_other_uses: true
      mode:
        input: true
        pullup: true

sensor:
  - platform: fusb302
    vbus:
      id: fusb_vbus
      name: "${name} PD VBus"
      filters:  # limit to 1 update/s or on fast change
        - or:
          - throttle : 1s
          - delta: 1.0
    selected_voltage:
      id: fusb_selected_voltage
      name: "${name} PD Selected Voltage"
    selected_current:
      id: fusb_selected_current
      name: "${name} PD Selected Current"
  - platform: mcp3561
    id: meas_voltage
    name: "${name} Meas Voltage"
    unit_of_measurement: V
    update_interval: 0.01s  # as fast as possible, limited by ADC conversion time
    accuracy_decimals: 4
    mcp3561_id: adc_meas
    channel: CH0
    channel_neg: CH2  # pin 2 is vcenter
    filters:
      - lambda: |-
          id(ratio_voltage).publish_state(x);
          id(adc_voltage).publish_state(id(meas_voltage).rawValue);
          return adcToValue(x, id(kVoltageRatio), id(kCalVoltageFactor).state, id(kCalVoltageOffset).state);
  - platform: mcp3561
    id: meas_current
    name: "${name} Meas Current"
    unit_of_measurement: A
    update_interval: 0.01s  # as fast as possible, limited by ADC conversion time
    accuracy_decimals: 5
    mcp3561_id: adc_meas
    channel: CH1
    channel_neg: CH2  # pin 2 is vcenter
    filters:
      - lambda: |-
          static int8_t lastRange = -1;  // -1=off, 0=range0, 1=...
          int8_t thisRange = -1;
          static bool lastSampleValid = true;
          if (id(range0)->state && !id(range1)->state && !id(range2)->state) {
            thisRange = 0;
          } else if (id(range1)->state && !id(range0)->state && !id(range2)->state) {
            thisRange = 1;
          } else if (id(range2)->state && !id(range0)->state && !id(range1)->state) {
            thisRange = 2;
          }
          id(ratio_current).publish_state(x);
          id(adc_current).publish_state(id(meas_current).rawValue);

          x = x + id(kCalCurrentSetSourceFactor).state * (x - id(dac_ratio_isrc).state)
            + id(kCalCurrentSetSinkFactor).state * (x - id(dac_ratio_isink).state)
            + id(kCalCurrentCommonFactor).state * id(ratio_voltage).state;

          if (lastRange != thisRange || thisRange < 0) {  // invalidate the measurement on a range change
            lastRange = thisRange;
            if (thisRange < 0 && !lastSampleValid) {  // send NaNs after an initial zero - the zero for integrators to not integrate over the dead time
              return NAN;
            } else {
              lastSampleValid = false;
              return 0;
            }
          }

          float value;
          if (thisRange == 0) {
            value = adcToValue(x, id(kCurrentRatio0), id(kCalCurrent0Factor).state, id(kCalCurrent0Offset).state);
          } else if (thisRange == 1) {
            value = adcToValue(x, id(kCurrentRatio1), id(kCalCurrent1Factor).state, id(kCalCurrent1Offset).state);
          } else if (thisRange == 2) {
            value = adcToValue(x, id(kCurrentRatio2), id(kCalCurrent2Factor).state, id(kCalCurrent2Offset).state);
          }
          lastSampleValid = true;
          return value;

  - platform: combination
    name: "${name} Meas Volage Max"
    id: meas_voltage_max
    type: sum  # dummy
    internal: true
    accuracy_decimals: 7
    sources:
      - source: meas_voltage
    filters:
      - max:
          window_size: 5
          send_every: 1

  - platform: combination
    name: "${name} Deriv Power"
    id: deriv_power
    type: sum  # dummy
    accuracy_decimals: 6
    unit_of_measurement: W
    sources:
      - source: meas_voltage
      - source: meas_current
    filters:
      - lambda: |-
          return id(meas_voltage).state * id(meas_current).state;

  - platform: integration
    name: "${name} Deriv Energy"
    id: deriv_energy
    sensor: deriv_power
    time_unit: s
    integration_method: left  # NaNs don't update state, this integrates the zero over the dead period
    accuracy_decimals: 6
    unit_of_measurement: J

  - platform: integration
    name: "${name} Deriv Cumulative Current"
    id: deriv_accum_current
    sensor: meas_current
    time_unit: h
    integration_method: left  # NaNs don't update state, this integrates the zero over the dead period
    accuracy_decimals: 6
    unit_of_measurement: Ah

  - platform: template  # pre-calibration, range [-0.5, 0.5]
    name: "${name} Meas Ratio Voltage"
    id: ratio_voltage
    accuracy_decimals: 8
    # internal: true
  - platform: template
    name: "${name} Meas Ratio Current"
    id: ratio_current
    accuracy_decimals: 8
    # internal: true
  - platform: template
    name: "${name} Meas ADC Voltage"
    id: adc_voltage
    accuracy_decimals: 0
    internal: true
  - platform: template
    name: "${name} Meas ADC Current"
    id: adc_current
    accuracy_decimals: 0
    internal: true

  - platform: template  # post-quantization, pre-calibration, range [-0.5, 0.5]
    name: "${name} Set Ratio Voltage"
    id: dac_ratio_voltage
    accuracy_decimals: 8
    # internal: true
  - platform: template
    name: "${name} Set Ratio Current Max"
    id: dac_ratio_isrc
    accuracy_decimals: 8
    # internal: true
  - platform: template
    name: "${name} Set Ratio Current Min"
    id: dac_ratio_isink
    accuracy_decimals: 8
    # internal: true
  - platform: template  # these are the raw DAC counts
    name: "${name} DAC Voltage"
    id: dac_value_voltage
    accuracy_decimals: 0
    internal: true
  - platform: template
    name: "${name} DAC Voltage Fine"
    id: dac_value_voltage_fine
    accuracy_decimals: 0
    internal: true
  - platform: template
    name: "${name} DAC Current Source Limit"
    id: dac_value_isrc
    accuracy_decimals: 0
    internal: true
  - platform: template
    name: "${name} DAC Current Sink Limit"
    id: dac_value_isink
    accuracy_decimals: 0
    internal: true

  - platform: pulse_counter
    pin: 
      number: GPIO14
      allow_other_uses: true
      mode:
        input: true
        pullup: true
    internal_filter: 0s
    update_interval: 50ms
    id: control_limit_source_rate
    internal: true
    total:
      id: control_limit_source_pulses
      name: "${name} Control Limit Source Pulses"
  - platform: pulse_counter
    pin: 
      number: GPIO21
      allow_other_uses: true
      mode:
        input: true
        pullup: true
    internal_filter: 0s
    update_interval: 50ms
    id: control_limit_sink_rate
    internal: true
    total:
      id: control_limit_sink_pulses
      name: "${name} Control Limit Sink Pulses"

  - platform: adc
    id: adc_vconv
    name: "${name} Int VConv"
    pin: GPIO8
    accuracy_decimals: 2
    update_interval: 0.25s
    attenuation: auto
    filters:
      - multiply: 14

sample_buffer:
  id: smu_meas
  sources:
    - source: meas_voltage
      name: "V"
    - source: meas_current
      name: "A"
    - source: deriv_energy
      name: "J"
    - source: deriv_accum_current
      name: "Ah"
